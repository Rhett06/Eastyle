[{"code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mem.collect;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Set;\n\nimport javassist.util.proxy.MethodFilter;\nimport javassist.util.proxy.MethodHandler;\nimport javassist.util.proxy.ProxyFactory;\n\nimport org.apache.commons.lang.SerializationException;\nimport org.apache.commons.lang.SerializationUtils;\nimport org.apache.crunch.Aggregator;\nimport org.apache.crunch.CachingOptions;\nimport org.apache.crunch.DoFn;\nimport org.apache.crunch.FilterFn;\nimport org.apache.crunch.IFilterFn;\nimport org.apache.crunch.IFlatMapFn;\nimport org.apache.crunch.IDoFn;\nimport org.apache.crunch.IMapFn;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.PCollection;\nimport org.apache.crunch.PObject;\nimport org.apache.crunch.PTable;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.ParallelDoOptions;\nimport org.apache.crunch.Pipeline;\nimport org.apache.crunch.ReadableData;\nimport org.apache.crunch.PipelineCallable;\nimport org.apache.crunch.Target;\nimport org.apache.crunch.fn.ExtractKeyFn;\nimport org.apache.crunch.fn.IFnHelpers;\nimport org.apache.crunch.impl.mem.MemPipeline;\nimport org.apache.crunch.impl.mem.emit.InMemoryEmitter;\nimport org.apache.crunch.lib.Aggregate;\nimport org.apache.crunch.materialize.pobject.CollectionPObject;\nimport org.apache.crunch.materialize.pobject.FirstElementPObject;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\nimport org.apache.crunch.types.PTypeFamily;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.StatusReporter;\nimport org.apache.hadoop.mapreduce.TaskAttemptID;\nimport org.apache.hadoop.mapreduce.TaskInputOutputContext;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\n\npublic class MemCollection<S> implements PCollection<S> {\n\n  private final Collection<S> collect;\n  private final PType<S> ptype;\n  private String name;\n\n  public MemCollection(Iterable<S> collect) {\n    this(collect, null, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype) {\n    this(collect, ptype, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype, String name) {\n    this.collect = ImmutableList.copyOf(collect);\n    this.ptype = ptype;\n    this.name = name;\n  }\n\n  @Override\n  public Pipeline getPipeline() {\n    return MemPipeline.getInstance();\n  }\n\n  @Override\n  public PCollection<S> union(PCollection<S> other) {\n    return union(new PCollection[] { other });\n  }\n  \n  @Override\n  public PCollection<S> union(PCollection<S>... collections) {\n    return getPipeline().union(\n        ImmutableList.<PCollection<S>>builder().add(this).add(collections).build());\n  }\n\n  private <S, T> DoFn<S, T> verifySerializable(String name, DoFn<S, T> doFn) {\n    try {\n      return (DoFn<S, T>) deserialize(SerializationUtils.serialize(doFn));\n    } catch (SerializationException e) {\n      throw new IllegalStateException(\n          doFn.getClass().getSimpleName() + \" named '\" + name + \"' cannot be serialized\",\n          e);\n    }\n  }\n\n  // Use a custom deserialize implementation (not SerializationUtils) so we can fall back\n  // to using the thread context classloader, which is needed when running Scrunch in\n  // the Scala REPL\n  private static Object deserialize(InputStream inputStream) {\n    if (inputStream == null) {\n      throw new IllegalArgumentException(\"The InputStream must not be null\");\n    }\n    ObjectInputStream in = null;\n    try {\n      // stream closed in the finally\n      in = new ObjectInputStream(inputStream) {\n        @Override\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,\n            ClassNotFoundException {\n          try {\n            return super.resolveClass(desc);\n          } catch (ClassNotFoundException e) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            return Class.forName(desc.getName(), false, cl);\n          }\n        }\n      };\n      return in.readObject();\n\n    } catch (ClassNotFoundException ex) {\n      throw new SerializationException(ex);\n    } catch (IOException ex) {\n      throw new SerializationException(ex);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n      } catch (IOException ex) {\n        // ignore close exception\n      }\n    }\n  }\n\n  private static Object deserialize(byte[] objectData) {\n    if (objectData == null) {\n      throw new IllegalArgumentException(\"The byte[] must not be null\");\n    }\n    ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    return deserialize(bais);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type,\n      ParallelDoOptions options) {\n    doFn = verifySerializable(name, doFn);\n    InMemoryEmitter<T> emitter = new InMemoryEmitter<T>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemCollection<T>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type,\n      ParallelDoOptions options) {\n    InMemoryEmitter<Pair<K, V>> emitter = new InMemoryEmitter<Pair<K, V>>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemTable<K, V>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(String name, IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(String name, IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(String name, IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(String name, IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  public PCollection<S> filter(IFilterFn<S> fn) {\n    return filter(IFnHelpers.wrapFilter(fn));\n  }\n\n  public PCollection<S> filter(String name, IFilterFn<S> fn) {\n    return filter(name, IFnHelpers.wrapFilter(fn));\n  }\n\n  @Override\n  public PCollection<S> write(Target target) {\n    getPipeline().write(this, target);\n    return this;\n  }\n\n  @Override\n  public PCollection<S> write(Target target, Target.WriteMode writeMode) {\n    getPipeline().write(this, target, writeMode);\n    return this;\n  }\n\n  @Override\n  public Iterable<S> materialize() {\n    return collect;\n  }\n\n  @Override\n  public PCollection<S> cache() {\n    // No-op\n    return this;\n  }\n\n  @Override\n  public PCollection<S> cache(CachingOptions options) {\n    // No-op\n    return this;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public PObject<Collection<S>> asCollection() {\n    return new CollectionPObject<S>(this);\n  }\n\n  @Override\n  public PObject<S> first() { return new FirstElementPObject<S>(this); }\n\n  @Override\n  public <Output> Output sequentialDo(String label, PipelineCallable<Output> pipelineCallable) {\n    pipelineCallable.dependsOn(label, this);\n    return getPipeline().sequentialDo(pipelineCallable);\n  }\n\n  @Override\n  public ReadableData<S> asReadable(boolean materialize) {\n    return new MemReadableData<S>(collect);\n  }\n\n  public Collection<S> getCollection() {\n    return collect;\n  }\n\n  @Override\n  public PType<S> getPType() {\n    return ptype;\n  }\n\n  @Override\n  public PTypeFamily getTypeFamily() {\n    if (ptype != null) {\n      return ptype.getFamily();\n    }\n    return null;\n  }\n\n  @Override\n  public long getSize() {\n    return collect.isEmpty() ? 0 : 1; // getSize is only used for pipeline optimization in MR\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String toString() {\n    return collect.toString();\n  }\n\n  @Override\n  public PTable<S, Long> count() {\n    return Aggregate.count(this);\n  }\n\n  @Override\n  public PObject<Long> length() {\n    return Aggregate.length(this);\n  }\n\n  @Override\n  public PObject<S> max() {\n    return Aggregate.max(this);\n  }\n\n  @Override\n  public PObject<S> min() {\n    return Aggregate.min(this);\n  }\n\n  @Override\n  public PCollection<S> aggregate(Aggregator<S> aggregator) {\n    return Aggregate.aggregate(this, aggregator);\n  }\n  \n  @Override\n  public PCollection<S> filter(FilterFn<S> filterFn) {\n    return parallelDo(filterFn, getPType());\n  }\n\n  @Override\n  public PCollection<S> filter(String name, FilterFn<S> filterFn) {\n    return parallelDo(name, filterFn, getPType());\n  }\n\n  @Override\n  public <K> PTable<K, S> by(MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(IMapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(IFnHelpers.wrapMap(mapFn)), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(String name, MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(name, new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  /**\n   * The method creates a {@link TaskInputOutputContext} that will just provide\n   * {@linkplain Configuration}. The method has been implemented with javaassist\n   * as there are API changes in versions of Hadoop. In hadoop 1.0.3 the\n   * {@linkplain TaskInputOutputContext} is abstract class while in version 2\n   * the same is an interface.\n   * <p>\n   * Note: The intention of this is to provide the bare essentials that are\n   * required to make the {@linkplain MemPipeline} work. It lacks even the basic\n   * things that can proved some support for unit testing pipeline.\n   */\n  private static TaskInputOutputContext<?, ?, ?, ?> getInMemoryContext(final Configuration conf) {\n    ProxyFactory factory = new ProxyFactory();\n    Class<TaskInputOutputContext> superType = TaskInputOutputContext.class;\n    Class[] types = new Class[0];\n    Object[] args = new Object[0];\n    final TaskAttemptID taskAttemptId = new TaskAttemptID();\n    if (superType.isInterface()) {\n      factory.setInterfaces(new Class[] { superType });\n    } else {\n      types = new Class[] { Configuration.class, TaskAttemptID.class, RecordWriter.class, OutputCommitter.class,\n          StatusReporter.class };\n      args = new Object[] { conf, taskAttemptId, null, null, null };\n      factory.setSuperclass(superType);\n    }\n\n    final Set<String> handledMethods = ImmutableSet.of(\"getConfiguration\", \"getCounter\", \n                                                  \"progress\", \"getNumReduceTasks\", \"getTaskAttemptID\");\n    factory.setFilter(new MethodFilter() {\n      @Override\n      public boolean isHandled(Method m) {\n        return handledMethods.contains(m.getName());\n      }\n    });\n    MethodHandler handler = new MethodHandler() {\n      @Override\n      public Object invoke(Object arg0, Method m, Method arg2, Object[] args) throws Throwable {\n        String name = m.getName();\n        if (\"getConfiguration\".equals(name)) {\n          return conf;\n        } else if (\"progress\".equals(name)) {\n          // no-op\n          return null;\n        } else if (\"getTaskAttemptID\".equals(name)) {\n          return taskAttemptId;\n        } else if (\"getNumReduceTasks\".equals(name)) {\n          return 1;\n        } else if (\"getCounter\".equals(name)){ // getCounter\n          if (args.length == 1) {\n            return MemPipeline.getCounters().findCounter((Enum<?>) args[0]);\n          } else {\n            return MemPipeline.getCounters().findCounter((String) args[0], (String) args[1]);\n          }\n        } else {\n          throw new IllegalStateException(\"Unhandled method \" + name);\n        }\n      }\n    };\n    try {\n      Object newInstance = factory.create(types, args, handler);\n      return (TaskInputOutputContext<?, ?, ?, ?>) newInstance;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "violation": null, "tokens": ["Comment", "1_NL", "package", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "2_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "2_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "2_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "2_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "1_NL", "import", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", ";", "2_NL", "public", "1_SP", "class", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "implements", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "{", "2_NL_2_ID_SP", "private", "1_SP", "final", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ";", "1_NL", "private", "1_SP", "final", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ";", "1_NL", "private", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ";", "2_NL", "public", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "this", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Null", "0_None", ",", "1_SP", "Null", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "public", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "this", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Null", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "public", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "this", "0_None", ".", "0_None", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "this", "0_None", ".", "0_None", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ";", "1_NL", "this", "0_None", ".", "0_None", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "{", "1_SP", "Identifier", "1_SP", "}", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "...", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "1_NL_4_ID_SP", "Identifier", "0_None", ".", "0_None", "<", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", ">", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_6_DD_SP", "}", "2_NL", "private", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "try", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ")", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "1_NL_4_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "+", "1_SP", "String", "1_SP", "+", "1_SP", "Identifier", "1_SP", "+", "1_SP", "String", "0_None", ",", "1_NL", "Identifier", "0_None", ")", "0_None", ";", "1_NL_6_DD_SP", "}", "1_NL_2_DD_SP", "}", "2_NL", "Comment", "1_NL", "Comment", "1_NL", "Comment", "1_NL", "private", "1_SP", "static", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "1_SP", "==", "1_SP", "Null", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "String", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Null", "0_None", ";", "1_NL", "try", "1_SP", "{", "1_NL_2_ID_SP", "Comment", "1_NL", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Annotation", "0_None", "Identifier", "1_NL", "protected", "1_SP", "Identifier", "0_None", "<", "0_None", "?", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "throws", "1_SP", "Identifier", "0_None", ",", "1_NL_4_ID_SP", "Identifier", "1_SP", "{", "1_NL_2_DD_SP", "try", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "super", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ",", "1_SP", "Boolean", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "0_None", ";", "1_NL", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "2_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "finally", "1_SP", "{", "1_NL_2_ID_SP", "try", "1_SP", "{", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "1_SP", "!=", "1_SP", "Null", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Comment", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "2_NL", "private", "1_SP", "static", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", "byte", "0_None", "[", "0_None", "]", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "1_SP", "==", "1_SP", "Null", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "String", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Null", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_NL_4_ID_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_DD_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "for", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "1_SP", ":", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Null", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_NL_4_ID_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_DD_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "for", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "1_SP", ":", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Null", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Null", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Null", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Null", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "<LineLength>", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "</LineLength>", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "this", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "this", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Comment", "1_NL", "return", "1_SP", "this", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Comment", "1_NL", "return", "1_SP", "this", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Comment", "1_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_SP", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "this", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "boolean", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "1_SP", "!=", "1_SP", "Null", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL", "return", "1_SP", "Null", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "long", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "?", "1_SP", "DecimalInteger", "1_SP", ":", "1_SP", "DecimalInteger", "0_None", ";", "1_SP", "Comment", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "this", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Comment", "1_NL", "private", "1_SP", "static", "1_SP", "Identifier", "0_None", "<", "0_None", "?", "0_None", ",", "1_SP", "?", "0_None", ",", "1_SP", "?", "0_None", ",", "1_SP", "?", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "final", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "class", "0_None", ";", "1_NL", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ";", "1_NL", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ";", "1_NL", "final", "1_SP", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "if", "1_SP", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "{", "1_SP", "Identifier", "1_SP", "}", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "{", "1_SP", "Identifier", "0_None", ".", "0_None", "class", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "class", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "class", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "class", "0_None", ",", "1_NL_4_ID_SP", "Identifier", "0_None", ".", "0_None", "class", "1_SP", "}", "0_None", ";", "1_NL_4_DD_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "{", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Null", "0_None", ",", "1_SP", "Null", "0_None", ",", "1_SP", "Null", "1_SP", "}", "0_None", ";", "1_NL", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "final", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "String", "0_None", ",", "1_SP", "String", "0_None", ",", "1_NL_46_ID_SP", "String", "0_None", ",", "1_SP", "String", "0_None", ",", "1_SP", "String", "0_None", ")", "0_None", ";", "1_NL_46_DD_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "new", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "boolean", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "0_None", ")", "0_None", ";", "1_NL", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "[", "0_None", "]", "1_SP", "Identifier", "0_None", ")", "1_SP", "throws", "1_SP", "Identifier", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Comment", "1_NL", "return", "1_SP", "Null", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "DecimalInteger", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "0_None", "{", "1_SP", "Comment", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "1_SP", "==", "1_SP", "DecimalInteger", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "?", "0_None", ">", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "(", "0_None", "Identifier", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ",", "1_SP", "(", "0_None", "Identifier", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "{", "1_NL_2_ID_SP", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "String", "1_SP", "+", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "0_None", ";", "1_NL", "try", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "1_SP", "Identifier", "1_SP", "=", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "(", "0_None", "Identifier", "0_None", "<", "0_None", "?", "0_None", ",", "1_SP", "?", "0_None", ",", "1_SP", "?", "0_None", ",", "1_SP", "?", "0_None", ">", "0_None", ")", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "catch", "1_SP", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ";", "1_NL", "throw", "1_SP", "new", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_NL"], "info": {"violation_beginning_token": 1723, "violation_end_token": 1767, "context_beginning_token": 0, "context_end_token": 3359, "violation": {"line": "243", "severity": "warning", "message": "Line is longer than 120 characters (found 129).", "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck", "type": "LineLength"}, "tokens_violating_in_tag": ["Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP"]}}, {"code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mem.collect;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Set;\n\nimport javassist.util.proxy.MethodFilter;\nimport javassist.util.proxy.MethodHandler;\nimport javassist.util.proxy.ProxyFactory;\n\nimport org.apache.commons.lang.SerializationException;\nimport org.apache.commons.lang.SerializationUtils;\nimport org.apache.crunch.Aggregator;\nimport org.apache.crunch.CachingOptions;\nimport org.apache.crunch.DoFn;\nimport org.apache.crunch.FilterFn;\nimport org.apache.crunch.IFilterFn;\nimport org.apache.crunch.IFlatMapFn;\nimport org.apache.crunch.IDoFn;\nimport org.apache.crunch.IMapFn;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.PCollection;\nimport org.apache.crunch.PObject;\nimport org.apache.crunch.PTable;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.ParallelDoOptions;\nimport org.apache.crunch.Pipeline;\nimport org.apache.crunch.ReadableData;\nimport org.apache.crunch.PipelineCallable;\nimport org.apache.crunch.Target;\nimport org.apache.crunch.fn.ExtractKeyFn;\nimport org.apache.crunch.fn.IFnHelpers;\nimport org.apache.crunch.impl.mem.MemPipeline;\nimport org.apache.crunch.impl.mem.emit.InMemoryEmitter;\nimport org.apache.crunch.lib.Aggregate;\nimport org.apache.crunch.materialize.pobject.CollectionPObject;\nimport org.apache.crunch.materialize.pobject.FirstElementPObject;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\nimport org.apache.crunch.types.PTypeFamily;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.StatusReporter;\nimport org.apache.hadoop.mapreduce.TaskAttemptID;\nimport org.apache.hadoop.mapreduce.TaskInputOutputContext;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\n\npublic class MemCollection<S> implements PCollection<S> {\n\n  private final Collection<S> collect;\n  private final PType<S> ptype;\n  private String name;\n\n  public MemCollection(Iterable<S> collect) {\n    this(collect, null, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype) {\n    this(collect, ptype, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype, String name) {\n    this.collect = ImmutableList.copyOf(collect);\n    this.ptype = ptype;\n    this.name = name;\n  }\n\n  @Override\n  public Pipeline getPipeline() {\n    return MemPipeline.getInstance();\n  }\n\n  @Override\n  public PCollection<S> union(PCollection<S> other) {\n    return union(new PCollection[] { other });\n  }\n  \n  @Override\n  public PCollection<S> union(PCollection<S>... collections) {\n    return getPipeline().union(\n        ImmutableList.<PCollection<S>>builder().add(this).add(collections).build());\n  }\n\n  private <S, T> DoFn<S, T> verifySerializable(String name, DoFn<S, T> doFn) {\n    try {\n      return (DoFn<S, T>) deserialize(SerializationUtils.serialize(doFn));\n    } catch (SerializationException e) {\n      throw new IllegalStateException(\n          doFn.getClass().getSimpleName() + \" named '\" + name + \"' cannot be serialized\",\n          e);\n    }\n  }\n\n  // Use a custom deserialize implementation (not SerializationUtils) so we can fall back\n  // to using the thread context classloader, which is needed when running Scrunch in\n  // the Scala REPL\n  private static Object deserialize(InputStream inputStream) {\n    if (inputStream == null) {\n      throw new IllegalArgumentException(\"The InputStream must not be null\");\n    }\n    ObjectInputStream in = null;\n    try {\n      // stream closed in the finally\n      in = new ObjectInputStream(inputStream) {\n        @Override\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,\n            ClassNotFoundException {\n          try {\n            return super.resolveClass(desc);\n          } catch (ClassNotFoundException e) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            return Class.forName(desc.getName(), false, cl);\n          }\n        }\n      };\n      return in.readObject();\n\n    } catch (ClassNotFoundException ex) {\n      throw new SerializationException(ex);\n    } catch (IOException ex) {\n      throw new SerializationException(ex);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n      } catch (IOException ex) {\n        // ignore close exception\n      }\n    }\n  }\n\n  private static Object deserialize(byte[] objectData) {\n    if (objectData == null) {\n      throw new IllegalArgumentException(\"The byte[] must not be null\");\n    }\n    ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    return deserialize(bais);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type,\n      ParallelDoOptions options) {\n    doFn = verifySerializable(name, doFn);\n    InMemoryEmitter<T> emitter = new InMemoryEmitter<T>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemCollection<T>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type,\n      ParallelDoOptions options) {\n    InMemoryEmitter<Pair<K, V>> emitter = new InMemoryEmitter<Pair<K, V>>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemTable<K, V>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(String name, IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(String name, IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(String name, IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(String name, IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  public PCollection<S> filter(IFilterFn<S> fn) {\n    return filter(IFnHelpers.wrapFilter(fn));\n  }\n\n  public PCollection<S> filter(String name, IFilterFn<S> fn) {\n    return filter(name, IFnHelpers.wrapFilter(fn));\n  }\n\n  @Override\n  public PCollection<S> write(Target target) {\n    getPipeline().write(this, target);\n    return this;\n  }\n\n  @Override\n  public PCollection<S> write(Target target, Target.WriteMode writeMode) {\n    getPipeline().write(this, target, writeMode);\n    return this;\n  }\n\n  @Override\n  public Iterable<S> materialize() {\n    return collect;\n  }\n\n  @Override\n  public PCollection<S> cache() {\n    // No-op\n    return this;\n  }\n\n  @Override\n  public PCollection<S> cache(CachingOptions options) {\n    // No-op\n    return this;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public PObject<Collection<S>> asCollection() {\n    return new CollectionPObject<S>(this);\n  }\n\n  @Override\n  public PObject<S> first() { return new FirstElementPObject<S>(this); }\n\n  @Override\n  public <Output> Output sequentialDo(String label, PipelineCallable<Output> pipelineCallable) {\n    pipelineCallable.dependsOn(label, this);\n    return getPipeline().sequentialDo(pipelineCallable);\n  }\n\n  @Override\n  public ReadableData<S> asReadable(boolean materialize) {\n    return new MemReadableData<S>(collect);\n  }\n\n  public Collection<S> getCollection() {\n    return collect;\n  }\n\n  @Override\n  public PType<S> getPType() {\n    return ptype;\n  }\n\n  @Override\n  public PTypeFamily getTypeFamily() {\n    if (ptype != null) {\n      return ptype.getFamily();\n    }\n    return null;\n  }\n\n  @Override\n  public long getSize() {\n    return collect.isEmpty() ? 0 : 1; // getSize is only used for pipeline optimization in MR\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String toString() {\n    return collect.toString();\n  }\n\n  @Override\n  public PTable<S, Long> count() {\n    return Aggregate.count(this);\n  }\n\n  @Override\n  public PObject<Long> length() {\n    return Aggregate.length(this);\n  }\n\n  @Override\n  public PObject<S> max() {\n    return Aggregate.max(this);\n  }\n\n  @Override\n  public PObject<S> min() {\n    return Aggregate.min(this);\n  }\n\n  @Override\n  public PCollection<S> aggregate(Aggregator<S> aggregator) {\n    return Aggregate.aggregate(this, aggregator);\n  }\n  \n  @Override\n  public PCollection<S> filter(FilterFn<S> filterFn) {\n    return parallelDo(filterFn, getPType());\n  }\n\n  @Override\n  public PCollection<S> filter(String name, FilterFn<S> filterFn) {\n    return parallelDo(name, filterFn, getPType());\n  }\n\n  @Override\n  public <K> PTable<K, S> by(MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(IMapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(IFnHelpers.wrapMap(mapFn)), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(String name, MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(name, new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  /**\n   * The method creates a {@link TaskInputOutputContext} that will just provide\n   * {@linkplain Configuration}. The method has been implemented with javaassist\n   * as there are API changes in versions of Hadoop. In hadoop 1.0.3 the\n   * {@linkplain TaskInputOutputContext} is abstract class while in version 2\n   * the same is an interface.\n   * <p>\n   * Note: The intention of this is to provide the bare essentials that are\n   * required to make the {@linkplain MemPipeline} work. It lacks even the basic\n   * things that can proved some support for unit testing pipeline.\n   */\n  private static TaskInputOutputContext<?, ?, ?, ?> getInMemoryContext(final Configuration conf) {\n    ProxyFactory factory = new ProxyFactory();\n    Class<TaskInputOutputContext> superType = TaskInputOutputContext.class;\n    Class[] types = new Class[0];\n    Object[] args = new Object[0];\n    final TaskAttemptID taskAttemptId = new TaskAttemptID();\n    if (superType.isInterface()) {\n      factory.setInterfaces(new Class[] { superType });\n    } else {\n      types = new Class[] { Configuration.class, TaskAttemptID.class, RecordWriter.class, OutputCommitter.class,\n          StatusReporter.class };\n      args = new Object[] { conf, taskAttemptId, null, null, null };\n      factory.setSuperclass(superType);\n    }\n\n    final Set<String> handledMethods = ImmutableSet.of(\"getConfiguration\", \"getCounter\", \n                                                  \"progress\", \"getNumReduceTasks\", \"getTaskAttemptID\");\n    factory.setFilter(new MethodFilter() {\n      @Override\n      public boolean isHandled(Method m) {\n        return handledMethods.contains(m.getName());\n      }\n    });\n    MethodHandler handler = new MethodHandler() {\n      @Override\n      public Object invoke(Object arg0, Method m, Method arg2, Object[] args) throws Throwable {\n        String name = m.getName();\n        if (\"getConfiguration\".equals(name)) {\n          return conf;\n        } else if (\"progress\".equals(name)) {\n          // no-op\n          return null;\n        } else if (\"getTaskAttemptID\".equals(name)) {\n          return taskAttemptId;\n        } else if (\"getNumReduceTasks\".equals(name)) {\n          return 1;\n        } else if (\"getCounter\".equals(name)){ // getCounter\n          if (args.length == 1) {\n            return MemPipeline.getCounters().findCounter((Enum<?>) args[0]);\n          } else {\n            return MemPipeline.getCounters().findCounter((String) args[0], (String) args[1]);\n          }\n        } else {\n          throw new IllegalStateException(\"Unhandled method \" + name);\n        }\n      }\n    };\n    try {\n      Object newInstance = factory.create(types, args, handler);\n      return (TaskInputOutputContext<?, ?, ?, ?>) newInstance;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "violation": {"line": "243", "severity": "warning", "message": "Line is longer than 120 characters (found 129).", "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck"}, "tokens": ["}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "<LineLength>", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "</LineLength>", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ",", "1_SP", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP"], "info": {"violation_beginning_token": 1723, "violation_end_token": 1767, "context_beginning_token": 1670, "context_end_token": 1824, "violation": {"line": "243", "severity": "warning", "message": "Line is longer than 120 characters (found 129).", "source": "com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck", "type": "LineLength"}, "tokens_violating_in_tag": ["Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP"]}}, {"code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mem.collect;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Set;\n\nimport javassist.util.proxy.MethodFilter;\nimport javassist.util.proxy.MethodHandler;\nimport javassist.util.proxy.ProxyFactory;\n\nimport org.apache.commons.lang.SerializationException;\nimport org.apache.commons.lang.SerializationUtils;\nimport org.apache.crunch.Aggregator;\nimport org.apache.crunch.CachingOptions;\nimport org.apache.crunch.DoFn;\nimport org.apache.crunch.FilterFn;\nimport org.apache.crunch.IFilterFn;\nimport org.apache.crunch.IFlatMapFn;\nimport org.apache.crunch.IDoFn;\nimport org.apache.crunch.IMapFn;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.PCollection;\nimport org.apache.crunch.PObject;\nimport org.apache.crunch.PTable;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.ParallelDoOptions;\nimport org.apache.crunch.Pipeline;\nimport org.apache.crunch.ReadableData;\nimport org.apache.crunch.PipelineCallable;\nimport org.apache.crunch.Target;\nimport org.apache.crunch.fn.ExtractKeyFn;\nimport org.apache.crunch.fn.IFnHelpers;\nimport org.apache.crunch.impl.mem.MemPipeline;\nimport org.apache.crunch.impl.mem.emit.InMemoryEmitter;\nimport org.apache.crunch.lib.Aggregate;\nimport org.apache.crunch.materialize.pobject.CollectionPObject;\nimport org.apache.crunch.materialize.pobject.FirstElementPObject;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\nimport org.apache.crunch.types.PTypeFamily;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.StatusReporter;\nimport org.apache.hadoop.mapreduce.TaskAttemptID;\nimport org.apache.hadoop.mapreduce.TaskInputOutputContext;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\n\npublic class MemCollection<S> implements PCollection<S> {\n\n  private final Collection<S> collect;\n  private final PType<S> ptype;\n  private String name;\n\n  public MemCollection(Iterable<S> collect) {\n    this(collect, null, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype) {\n    this(collect, ptype, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype, String name) {\n    this.collect = ImmutableList.copyOf(collect);\n    this.ptype = ptype;\n    this.name = name;\n  }\n\n  @Override\n  public Pipeline getPipeline() {\n    return MemPipeline.getInstance();\n  }\n\n  @Override\n  public PCollection<S> union(PCollection<S> other) {\n    return union(new PCollection[] { other });\n  }\n  \n  @Override\n  public PCollection<S> union(PCollection<S>... collections) {\n    return getPipeline().union(\n        ImmutableList.<PCollection<S>>builder().add(this).add(collections).build());\n  }\n\n  private <S, T> DoFn<S, T> verifySerializable(String name, DoFn<S, T> doFn) {\n    try {\n      return (DoFn<S, T>) deserialize(SerializationUtils.serialize(doFn));\n    } catch (SerializationException e) {\n      throw new IllegalStateException(\n          doFn.getClass().getSimpleName() + \" named '\" + name + \"' cannot be serialized\",\n          e);\n    }\n  }\n\n  // Use a custom deserialize implementation (not SerializationUtils) so we can fall back\n  // to using the thread context classloader, which is needed when running Scrunch in\n  // the Scala REPL\n  private static Object deserialize(InputStream inputStream) {\n    if (inputStream == null) {\n      throw new IllegalArgumentException(\"The InputStream must not be null\");\n    }\n    ObjectInputStream in = null;\n    try {\n      // stream closed in the finally\n      in = new ObjectInputStream(inputStream) {\n        @Override\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,\n            ClassNotFoundException {\n          try {\n            return super.resolveClass(desc);\n          } catch (ClassNotFoundException e) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            return Class.forName(desc.getName(), false, cl);\n          }\n        }\n      };\n      return in.readObject();\n\n    } catch (ClassNotFoundException ex) {\n      throw new SerializationException(ex);\n    } catch (IOException ex) {\n      throw new SerializationException(ex);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n      } catch (IOException ex) {\n        // ignore close exception\n      }\n    }\n  }\n\n  private static Object deserialize(byte[] objectData) {\n    if (objectData == null) {\n      throw new IllegalArgumentException(\"The byte[] must not be null\");\n    }\n    ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    return deserialize(bais);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type,\n      ParallelDoOptions options) {\n    doFn = verifySerializable(name, doFn);\n    InMemoryEmitter<T> emitter = new InMemoryEmitter<T>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemCollection<T>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type,\n      ParallelDoOptions options) {\n    InMemoryEmitter<Pair<K, V>> emitter = new InMemoryEmitter<Pair<K, V>>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemTable<K, V>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(String name, IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(String name, IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(String name, IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(String name, IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  public PCollection<S> filter(IFilterFn<S> fn) {\n    return filter(IFnHelpers.wrapFilter(fn));\n  }\n\n  public PCollection<S> filter(String name, IFilterFn<S> fn) {\n    return filter(name, IFnHelpers.wrapFilter(fn));\n  }\n\n  @Override\n  public PCollection<S> write(Target target) {\n    getPipeline().write(this, target);\n    return this;\n  }\n\n  @Override\n  public PCollection<S> write(Target target, Target.WriteMode writeMode) {\n    getPipeline().write(this, target, writeMode);\n    return this;\n  }\n\n  @Override\n  public Iterable<S> materialize() {\n    return collect;\n  }\n\n  @Override\n  public PCollection<S> cache() {\n    // No-op\n    return this;\n  }\n\n  @Override\n  public PCollection<S> cache(CachingOptions options) {\n    // No-op\n    return this;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public PObject<Collection<S>> asCollection() {\n    return new CollectionPObject<S>(this);\n  }\n\n  @Override\n  public PObject<S> first() { return new FirstElementPObject<S>(this); }\n\n  @Override\n  public <Output> Output sequentialDo(String label, PipelineCallable<Output> pipelineCallable) {\n    pipelineCallable.dependsOn(label, this);\n    return getPipeline().sequentialDo(pipelineCallable);\n  }\n\n  @Override\n  public ReadableData<S> asReadable(boolean materialize) {\n    return new MemReadableData<S>(collect);\n  }\n\n  public Collection<S> getCollection() {\n    return collect;\n  }\n\n  @Override\n  public PType<S> getPType() {\n    return ptype;\n  }\n\n  @Override\n  public PTypeFamily getTypeFamily() {\n    if (ptype != null) {\n      return ptype.getFamily();\n    }\n    return null;\n  }\n\n  @Override\n  public long getSize() {\n    return collect.isEmpty() ? 0 : 1; // getSize is only used for pipeline optimization in MR\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String toString() {\n    return collect.toString();\n  }\n\n  @Override\n  public PTable<S, Long> count() {\n    return Aggregate.count(this);\n  }\n\n  @Override\n  public PObject<Long> length() {\n    return Aggregate.length(this);\n  }\n\n  @Override\n  public PObject<S> max() {\n    return Aggregate.max(this);\n  }\n\n  @Override\n  public PObject<S> min() {\n    return Aggregate.min(this);\n  }\n\n  @Override\n  public PCollection<S> aggregate(Aggregator<S> aggregator) {\n    return Aggregate.aggregate(this, aggregator);\n  }\n  \n  @Override\n  public PCollection<S> filter(FilterFn<S> filterFn) {\n    return parallelDo(filterFn, getPType());\n  }\n\n  @Override\n  public PCollection<S> filter(String name, FilterFn<S> filterFn) {\n    return parallelDo(name, filterFn, getPType());\n  }\n\n  @Override\n  public <K> PTable<K, S> by(MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(IMapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(IFnHelpers.wrapMap(mapFn)), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(String name, MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(name, new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  /**\n   * The method creates a {@link TaskInputOutputContext} that will just provide\n   * {@linkplain Configuration}. The method has been implemented with javaassist\n   * as there are API changes in versions of Hadoop. In hadoop 1.0.3 the\n   * {@linkplain TaskInputOutputContext} is abstract class while in version 2\n   * the same is an interface.\n   * <p>\n   * Note: The intention of this is to provide the bare essentials that are\n   * required to make the {@linkplain MemPipeline} work. It lacks even the basic\n   * things that can proved some support for unit testing pipeline.\n   */\n  private static TaskInputOutputContext<?, ?, ?, ?> getInMemoryContext(final Configuration conf) {\n    ProxyFactory factory = new ProxyFactory();\n    Class<TaskInputOutputContext> superType = TaskInputOutputContext.class;\n    Class[] types = new Class[0];\n    Object[] args = new Object[0];\n    final TaskAttemptID taskAttemptId = new TaskAttemptID();\n    if (superType.isInterface()) {\n      factory.setInterfaces(new Class[] { superType });\n    } else {\n      types = new Class[] { Configuration.class, TaskAttemptID.class, RecordWriter.class, OutputCommitter.class,\n          StatusReporter.class };\n      args = new Object[] { conf, taskAttemptId, null, null, null };\n      factory.setSuperclass(superType);\n    }\n\n    final Set<String> handledMethods = ImmutableSet.of(\"getConfiguration\", \"getCounter\", \n                                                  \"progress\", \"getNumReduceTasks\", \"getTaskAttemptID\");\n    factory.setFilter(new MethodFilter() {\n      @Override\n      public boolean isHandled(Method m) {\n        return handledMethods.contains(m.getName());\n      }\n    });\n    MethodHandler handler = new MethodHandler() {\n      @Override\n      public Object invoke(Object arg0, Method m, Method arg2, Object[] args) throws Throwable {\n        String name = m.getName();\n        if (\"getConfiguration\".equals(name)) {\n          return conf;\n        } else if (\"progress\".equals(name)) {\n          // no-op\n          return null;\n        } else if (\"getTaskAttemptID\".equals(name)) {\n          return taskAttemptId;\n        } else if (\"getNumReduceTasks\".equals(name)) {\n          return 1;\n        } else if (\"getCounter\".equals(name)){ // getCounter\n          if (args.length == 1) {\n            return MemPipeline.getCounters().findCounter((Enum<?>) args[0]);\n          } else {\n            return MemPipeline.getCounters().findCounter((String) args[0], (String) args[1]);\n          }\n        } else {\n          throw new IllegalStateException(\"Unhandled method \" + name);\n        }\n      }\n    };\n    try {\n      Object newInstance = factory.create(types, args, handler);\n      return (TaskInputOutputContext<?, ?, ?, ?>) newInstance;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "violation": {"line": "331", "column": "29", "severity": "warning", "message": "'{' at column 29 should have line break after.", "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck"}, "tokens": ["Comment", "1_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", "(", "0_None", "<LeftCurly>", ")", "1_SP", "{", "1_SP", "</LeftCurly>", "return", "1_SP", "new", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "0_None", "(", "0_None", "this", "0_None", ")", "0_None", ";", "1_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", "Identifier", "1_SP", "Identifier", "0_None", ",", "1_SP", "Identifier", "0_None", "<", "0_None", "Identifier", "0_None", ">", "1_SP", "Identifier", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ",", "1_SP", "this", "0_None", ")", "0_None", ";", "1_NL", "return", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL"], "info": {"violation_beginning_token": 2380, "violation_end_token": 2382, "context_beginning_token": 2345, "context_end_token": 2432, "violation": {"line": "331", "column": "29", "severity": "warning", "message": "'{' at column 29 should have line break after.", "source": "com.puppycrawl.tools.checkstyle.checks.blocks.LeftCurlyCheck", "type": "LeftCurly"}, "tokens_violating_in_tag": [")", "1_SP", "{", "1_SP"]}}, {"code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mem.collect;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Set;\n\nimport javassist.util.proxy.MethodFilter;\nimport javassist.util.proxy.MethodHandler;\nimport javassist.util.proxy.ProxyFactory;\n\nimport org.apache.commons.lang.SerializationException;\nimport org.apache.commons.lang.SerializationUtils;\nimport org.apache.crunch.Aggregator;\nimport org.apache.crunch.CachingOptions;\nimport org.apache.crunch.DoFn;\nimport org.apache.crunch.FilterFn;\nimport org.apache.crunch.IFilterFn;\nimport org.apache.crunch.IFlatMapFn;\nimport org.apache.crunch.IDoFn;\nimport org.apache.crunch.IMapFn;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.PCollection;\nimport org.apache.crunch.PObject;\nimport org.apache.crunch.PTable;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.ParallelDoOptions;\nimport org.apache.crunch.Pipeline;\nimport org.apache.crunch.ReadableData;\nimport org.apache.crunch.PipelineCallable;\nimport org.apache.crunch.Target;\nimport org.apache.crunch.fn.ExtractKeyFn;\nimport org.apache.crunch.fn.IFnHelpers;\nimport org.apache.crunch.impl.mem.MemPipeline;\nimport org.apache.crunch.impl.mem.emit.InMemoryEmitter;\nimport org.apache.crunch.lib.Aggregate;\nimport org.apache.crunch.materialize.pobject.CollectionPObject;\nimport org.apache.crunch.materialize.pobject.FirstElementPObject;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\nimport org.apache.crunch.types.PTypeFamily;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.StatusReporter;\nimport org.apache.hadoop.mapreduce.TaskAttemptID;\nimport org.apache.hadoop.mapreduce.TaskInputOutputContext;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\n\npublic class MemCollection<S> implements PCollection<S> {\n\n  private final Collection<S> collect;\n  private final PType<S> ptype;\n  private String name;\n\n  public MemCollection(Iterable<S> collect) {\n    this(collect, null, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype) {\n    this(collect, ptype, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype, String name) {\n    this.collect = ImmutableList.copyOf(collect);\n    this.ptype = ptype;\n    this.name = name;\n  }\n\n  @Override\n  public Pipeline getPipeline() {\n    return MemPipeline.getInstance();\n  }\n\n  @Override\n  public PCollection<S> union(PCollection<S> other) {\n    return union(new PCollection[] { other });\n  }\n  \n  @Override\n  public PCollection<S> union(PCollection<S>... collections) {\n    return getPipeline().union(\n        ImmutableList.<PCollection<S>>builder().add(this).add(collections).build());\n  }\n\n  private <S, T> DoFn<S, T> verifySerializable(String name, DoFn<S, T> doFn) {\n    try {\n      return (DoFn<S, T>) deserialize(SerializationUtils.serialize(doFn));\n    } catch (SerializationException e) {\n      throw new IllegalStateException(\n          doFn.getClass().getSimpleName() + \" named '\" + name + \"' cannot be serialized\",\n          e);\n    }\n  }\n\n  // Use a custom deserialize implementation (not SerializationUtils) so we can fall back\n  // to using the thread context classloader, which is needed when running Scrunch in\n  // the Scala REPL\n  private static Object deserialize(InputStream inputStream) {\n    if (inputStream == null) {\n      throw new IllegalArgumentException(\"The InputStream must not be null\");\n    }\n    ObjectInputStream in = null;\n    try {\n      // stream closed in the finally\n      in = new ObjectInputStream(inputStream) {\n        @Override\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,\n            ClassNotFoundException {\n          try {\n            return super.resolveClass(desc);\n          } catch (ClassNotFoundException e) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            return Class.forName(desc.getName(), false, cl);\n          }\n        }\n      };\n      return in.readObject();\n\n    } catch (ClassNotFoundException ex) {\n      throw new SerializationException(ex);\n    } catch (IOException ex) {\n      throw new SerializationException(ex);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n      } catch (IOException ex) {\n        // ignore close exception\n      }\n    }\n  }\n\n  private static Object deserialize(byte[] objectData) {\n    if (objectData == null) {\n      throw new IllegalArgumentException(\"The byte[] must not be null\");\n    }\n    ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    return deserialize(bais);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type,\n      ParallelDoOptions options) {\n    doFn = verifySerializable(name, doFn);\n    InMemoryEmitter<T> emitter = new InMemoryEmitter<T>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemCollection<T>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type,\n      ParallelDoOptions options) {\n    InMemoryEmitter<Pair<K, V>> emitter = new InMemoryEmitter<Pair<K, V>>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemTable<K, V>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(String name, IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(String name, IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(String name, IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(String name, IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  public PCollection<S> filter(IFilterFn<S> fn) {\n    return filter(IFnHelpers.wrapFilter(fn));\n  }\n\n  public PCollection<S> filter(String name, IFilterFn<S> fn) {\n    return filter(name, IFnHelpers.wrapFilter(fn));\n  }\n\n  @Override\n  public PCollection<S> write(Target target) {\n    getPipeline().write(this, target);\n    return this;\n  }\n\n  @Override\n  public PCollection<S> write(Target target, Target.WriteMode writeMode) {\n    getPipeline().write(this, target, writeMode);\n    return this;\n  }\n\n  @Override\n  public Iterable<S> materialize() {\n    return collect;\n  }\n\n  @Override\n  public PCollection<S> cache() {\n    // No-op\n    return this;\n  }\n\n  @Override\n  public PCollection<S> cache(CachingOptions options) {\n    // No-op\n    return this;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public PObject<Collection<S>> asCollection() {\n    return new CollectionPObject<S>(this);\n  }\n\n  @Override\n  public PObject<S> first() { return new FirstElementPObject<S>(this); }\n\n  @Override\n  public <Output> Output sequentialDo(String label, PipelineCallable<Output> pipelineCallable) {\n    pipelineCallable.dependsOn(label, this);\n    return getPipeline().sequentialDo(pipelineCallable);\n  }\n\n  @Override\n  public ReadableData<S> asReadable(boolean materialize) {\n    return new MemReadableData<S>(collect);\n  }\n\n  public Collection<S> getCollection() {\n    return collect;\n  }\n\n  @Override\n  public PType<S> getPType() {\n    return ptype;\n  }\n\n  @Override\n  public PTypeFamily getTypeFamily() {\n    if (ptype != null) {\n      return ptype.getFamily();\n    }\n    return null;\n  }\n\n  @Override\n  public long getSize() {\n    return collect.isEmpty() ? 0 : 1; // getSize is only used for pipeline optimization in MR\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String toString() {\n    return collect.toString();\n  }\n\n  @Override\n  public PTable<S, Long> count() {\n    return Aggregate.count(this);\n  }\n\n  @Override\n  public PObject<Long> length() {\n    return Aggregate.length(this);\n  }\n\n  @Override\n  public PObject<S> max() {\n    return Aggregate.max(this);\n  }\n\n  @Override\n  public PObject<S> min() {\n    return Aggregate.min(this);\n  }\n\n  @Override\n  public PCollection<S> aggregate(Aggregator<S> aggregator) {\n    return Aggregate.aggregate(this, aggregator);\n  }\n  \n  @Override\n  public PCollection<S> filter(FilterFn<S> filterFn) {\n    return parallelDo(filterFn, getPType());\n  }\n\n  @Override\n  public PCollection<S> filter(String name, FilterFn<S> filterFn) {\n    return parallelDo(name, filterFn, getPType());\n  }\n\n  @Override\n  public <K> PTable<K, S> by(MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(IMapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(IFnHelpers.wrapMap(mapFn)), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(String name, MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(name, new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  /**\n   * The method creates a {@link TaskInputOutputContext} that will just provide\n   * {@linkplain Configuration}. The method has been implemented with javaassist\n   * as there are API changes in versions of Hadoop. In hadoop 1.0.3 the\n   * {@linkplain TaskInputOutputContext} is abstract class while in version 2\n   * the same is an interface.\n   * <p>\n   * Note: The intention of this is to provide the bare essentials that are\n   * required to make the {@linkplain MemPipeline} work. It lacks even the basic\n   * things that can proved some support for unit testing pipeline.\n   */\n  private static TaskInputOutputContext<?, ?, ?, ?> getInMemoryContext(final Configuration conf) {\n    ProxyFactory factory = new ProxyFactory();\n    Class<TaskInputOutputContext> superType = TaskInputOutputContext.class;\n    Class[] types = new Class[0];\n    Object[] args = new Object[0];\n    final TaskAttemptID taskAttemptId = new TaskAttemptID();\n    if (superType.isInterface()) {\n      factory.setInterfaces(new Class[] { superType });\n    } else {\n      types = new Class[] { Configuration.class, TaskAttemptID.class, RecordWriter.class, OutputCommitter.class,\n          StatusReporter.class };\n      args = new Object[] { conf, taskAttemptId, null, null, null };\n      factory.setSuperclass(superType);\n    }\n\n    final Set<String> handledMethods = ImmutableSet.of(\"getConfiguration\", \"getCounter\", \n                                                  \"progress\", \"getNumReduceTasks\", \"getTaskAttemptID\");\n    factory.setFilter(new MethodFilter() {\n      @Override\n      public boolean isHandled(Method m) {\n        return handledMethods.contains(m.getName());\n      }\n    });\n    MethodHandler handler = new MethodHandler() {\n      @Override\n      public Object invoke(Object arg0, Method m, Method arg2, Object[] args) throws Throwable {\n        String name = m.getName();\n        if (\"getConfiguration\".equals(name)) {\n          return conf;\n        } else if (\"progress\".equals(name)) {\n          // no-op\n          return null;\n        } else if (\"getTaskAttemptID\".equals(name)) {\n          return taskAttemptId;\n        } else if (\"getNumReduceTasks\".equals(name)) {\n          return 1;\n        } else if (\"getCounter\".equals(name)){ // getCounter\n          if (args.length == 1) {\n            return MemPipeline.getCounters().findCounter((Enum<?>) args[0]);\n          } else {\n            return MemPipeline.getCounters().findCounter((String) args[0], (String) args[1]);\n          }\n        } else {\n          throw new IllegalStateException(\"Unhandled method \" + name);\n        }\n      }\n    };\n    try {\n      Object newInstance = factory.create(types, args, handler);\n      return (TaskInputOutputContext<?, ?, ?, ?>) newInstance;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "violation": {"line": "363", "column": "30", "severity": "warning", "message": "Avoid inline conditionals.", "source": "com.puppycrawl.tools.checkstyle.checks.coding.AvoidInlineConditionalsCheck"}, "tokens": [";", "1_NL_2_DD_SP", "}", "1_NL", "return", "1_SP", "Null", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "long", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "<AvoidInlineConditionals>", ")", "1_SP", "?", "1_SP", "</AvoidInlineConditionals>", "DecimalInteger", "1_SP", ":", "1_SP", "DecimalInteger", "0_None", ";", "1_SP", "Comment", "1_NL_2_DD_SP", "}", "2_NL", "Annotation", "0_None", "Identifier", "1_NL", "public", "1_SP", "Identifier", "1_SP", "Identifier", "0_None", "(", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "2_NL"], "info": {"violation_beginning_token": 2524, "violation_end_token": 2526, "context_beginning_token": 2505, "context_end_token": 2544, "violation": {"line": "363", "column": "30", "severity": "warning", "message": "Avoid inline conditionals.", "source": "com.puppycrawl.tools.checkstyle.checks.coding.AvoidInlineConditionalsCheck", "type": "AvoidInlineConditionals"}, "tokens_violating_in_tag": [")", "1_SP", "?", "1_SP"]}}, {"code": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mem.collect;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Set;\n\nimport javassist.util.proxy.MethodFilter;\nimport javassist.util.proxy.MethodHandler;\nimport javassist.util.proxy.ProxyFactory;\n\nimport org.apache.commons.lang.SerializationException;\nimport org.apache.commons.lang.SerializationUtils;\nimport org.apache.crunch.Aggregator;\nimport org.apache.crunch.CachingOptions;\nimport org.apache.crunch.DoFn;\nimport org.apache.crunch.FilterFn;\nimport org.apache.crunch.IFilterFn;\nimport org.apache.crunch.IFlatMapFn;\nimport org.apache.crunch.IDoFn;\nimport org.apache.crunch.IMapFn;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.PCollection;\nimport org.apache.crunch.PObject;\nimport org.apache.crunch.PTable;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.ParallelDoOptions;\nimport org.apache.crunch.Pipeline;\nimport org.apache.crunch.ReadableData;\nimport org.apache.crunch.PipelineCallable;\nimport org.apache.crunch.Target;\nimport org.apache.crunch.fn.ExtractKeyFn;\nimport org.apache.crunch.fn.IFnHelpers;\nimport org.apache.crunch.impl.mem.MemPipeline;\nimport org.apache.crunch.impl.mem.emit.InMemoryEmitter;\nimport org.apache.crunch.lib.Aggregate;\nimport org.apache.crunch.materialize.pobject.CollectionPObject;\nimport org.apache.crunch.materialize.pobject.FirstElementPObject;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\nimport org.apache.crunch.types.PTypeFamily;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.StatusReporter;\nimport org.apache.hadoop.mapreduce.TaskAttemptID;\nimport org.apache.hadoop.mapreduce.TaskInputOutputContext;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\n\npublic class MemCollection<S> implements PCollection<S> {\n\n  private final Collection<S> collect;\n  private final PType<S> ptype;\n  private String name;\n\n  public MemCollection(Iterable<S> collect) {\n    this(collect, null, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype) {\n    this(collect, ptype, null);\n  }\n\n  public MemCollection(Iterable<S> collect, PType<S> ptype, String name) {\n    this.collect = ImmutableList.copyOf(collect);\n    this.ptype = ptype;\n    this.name = name;\n  }\n\n  @Override\n  public Pipeline getPipeline() {\n    return MemPipeline.getInstance();\n  }\n\n  @Override\n  public PCollection<S> union(PCollection<S> other) {\n    return union(new PCollection[] { other });\n  }\n  \n  @Override\n  public PCollection<S> union(PCollection<S>... collections) {\n    return getPipeline().union(\n        ImmutableList.<PCollection<S>>builder().add(this).add(collections).build());\n  }\n\n  private <S, T> DoFn<S, T> verifySerializable(String name, DoFn<S, T> doFn) {\n    try {\n      return (DoFn<S, T>) deserialize(SerializationUtils.serialize(doFn));\n    } catch (SerializationException e) {\n      throw new IllegalStateException(\n          doFn.getClass().getSimpleName() + \" named '\" + name + \"' cannot be serialized\",\n          e);\n    }\n  }\n\n  // Use a custom deserialize implementation (not SerializationUtils) so we can fall back\n  // to using the thread context classloader, which is needed when running Scrunch in\n  // the Scala REPL\n  private static Object deserialize(InputStream inputStream) {\n    if (inputStream == null) {\n      throw new IllegalArgumentException(\"The InputStream must not be null\");\n    }\n    ObjectInputStream in = null;\n    try {\n      // stream closed in the finally\n      in = new ObjectInputStream(inputStream) {\n        @Override\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException,\n            ClassNotFoundException {\n          try {\n            return super.resolveClass(desc);\n          } catch (ClassNotFoundException e) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            return Class.forName(desc.getName(), false, cl);\n          }\n        }\n      };\n      return in.readObject();\n\n    } catch (ClassNotFoundException ex) {\n      throw new SerializationException(ex);\n    } catch (IOException ex) {\n      throw new SerializationException(ex);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n      } catch (IOException ex) {\n        // ignore close exception\n      }\n    }\n  }\n\n  private static Object deserialize(byte[] objectData) {\n    if (objectData == null) {\n      throw new IllegalArgumentException(\"The byte[] must not be null\");\n    }\n    ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    return deserialize(bais);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <T> PCollection<T> parallelDo(String name, DoFn<S, T> doFn, PType<T> type,\n      ParallelDoOptions options) {\n    doFn = verifySerializable(name, doFn);\n    InMemoryEmitter<T> emitter = new InMemoryEmitter<T>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemCollection<T>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(null, doFn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type) {\n    return parallelDo(name, doFn, type, ParallelDoOptions.builder().build());\n  }\n  \n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, DoFn<S, Pair<K, V>> doFn, PTableType<K, V> type,\n      ParallelDoOptions options) {\n    InMemoryEmitter<Pair<K, V>> emitter = new InMemoryEmitter<Pair<K, V>>();\n    Configuration conf = getPipeline().getConfiguration();\n    doFn.configure(conf);\n    doFn.setContext(getInMemoryContext(conf));\n    doFn.initialize();\n    for (S s : collect) {\n      doFn.process(s, emitter);\n    }\n    doFn.cleanup(emitter);\n    return new MemTable<K, V>(emitter.getOutput(), type, name);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(null, fn, type);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, fn, type, null);\n  }\n\n  @Override\n  public <T> PCollection<T> parallelDo(String name, IDoFn<S, T> fn, PType<T> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> parallelDo(String name, IDoFn<S, Pair<K, V>> fn, PTableType<K, V> type, ParallelDoOptions options) {\n    return parallelDo(name, IFnHelpers.wrap(fn), type, options);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> flatMap(String name, IFlatMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> flatMap(String name, IFlatMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapFlatMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <T> PCollection<T> map(String name, IMapFn<S, T> fn, PType<T> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  @Override\n  public <K, V> PTable<K, V> map(String name, IMapFn<S, Pair<K, V>> fn, PTableType<K, V> type) {\n    return parallelDo(name, IFnHelpers.wrapMap(fn), type);\n  }\n\n  public PCollection<S> filter(IFilterFn<S> fn) {\n    return filter(IFnHelpers.wrapFilter(fn));\n  }\n\n  public PCollection<S> filter(String name, IFilterFn<S> fn) {\n    return filter(name, IFnHelpers.wrapFilter(fn));\n  }\n\n  @Override\n  public PCollection<S> write(Target target) {\n    getPipeline().write(this, target);\n    return this;\n  }\n\n  @Override\n  public PCollection<S> write(Target target, Target.WriteMode writeMode) {\n    getPipeline().write(this, target, writeMode);\n    return this;\n  }\n\n  @Override\n  public Iterable<S> materialize() {\n    return collect;\n  }\n\n  @Override\n  public PCollection<S> cache() {\n    // No-op\n    return this;\n  }\n\n  @Override\n  public PCollection<S> cache(CachingOptions options) {\n    // No-op\n    return this;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public PObject<Collection<S>> asCollection() {\n    return new CollectionPObject<S>(this);\n  }\n\n  @Override\n  public PObject<S> first() { return new FirstElementPObject<S>(this); }\n\n  @Override\n  public <Output> Output sequentialDo(String label, PipelineCallable<Output> pipelineCallable) {\n    pipelineCallable.dependsOn(label, this);\n    return getPipeline().sequentialDo(pipelineCallable);\n  }\n\n  @Override\n  public ReadableData<S> asReadable(boolean materialize) {\n    return new MemReadableData<S>(collect);\n  }\n\n  public Collection<S> getCollection() {\n    return collect;\n  }\n\n  @Override\n  public PType<S> getPType() {\n    return ptype;\n  }\n\n  @Override\n  public PTypeFamily getTypeFamily() {\n    if (ptype != null) {\n      return ptype.getFamily();\n    }\n    return null;\n  }\n\n  @Override\n  public long getSize() {\n    return collect.isEmpty() ? 0 : 1; // getSize is only used for pipeline optimization in MR\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String toString() {\n    return collect.toString();\n  }\n\n  @Override\n  public PTable<S, Long> count() {\n    return Aggregate.count(this);\n  }\n\n  @Override\n  public PObject<Long> length() {\n    return Aggregate.length(this);\n  }\n\n  @Override\n  public PObject<S> max() {\n    return Aggregate.max(this);\n  }\n\n  @Override\n  public PObject<S> min() {\n    return Aggregate.min(this);\n  }\n\n  @Override\n  public PCollection<S> aggregate(Aggregator<S> aggregator) {\n    return Aggregate.aggregate(this, aggregator);\n  }\n  \n  @Override\n  public PCollection<S> filter(FilterFn<S> filterFn) {\n    return parallelDo(filterFn, getPType());\n  }\n\n  @Override\n  public PCollection<S> filter(String name, FilterFn<S> filterFn) {\n    return parallelDo(name, filterFn, getPType());\n  }\n\n  @Override\n  public <K> PTable<K, S> by(MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(IMapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(new ExtractKeyFn<K, S>(IFnHelpers.wrapMap(mapFn)), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  @Override\n  public <K> PTable<K, S> by(String name, MapFn<S, K> mapFn, PType<K> keyType) {\n    return parallelDo(name, new ExtractKeyFn<K, S>(mapFn), getTypeFamily().tableOf(keyType, getPType()));\n  }\n\n  /**\n   * The method creates a {@link TaskInputOutputContext} that will just provide\n   * {@linkplain Configuration}. The method has been implemented with javaassist\n   * as there are API changes in versions of Hadoop. In hadoop 1.0.3 the\n   * {@linkplain TaskInputOutputContext} is abstract class while in version 2\n   * the same is an interface.\n   * <p>\n   * Note: The intention of this is to provide the bare essentials that are\n   * required to make the {@linkplain MemPipeline} work. It lacks even the basic\n   * things that can proved some support for unit testing pipeline.\n   */\n  private static TaskInputOutputContext<?, ?, ?, ?> getInMemoryContext(final Configuration conf) {\n    ProxyFactory factory = new ProxyFactory();\n    Class<TaskInputOutputContext> superType = TaskInputOutputContext.class;\n    Class[] types = new Class[0];\n    Object[] args = new Object[0];\n    final TaskAttemptID taskAttemptId = new TaskAttemptID();\n    if (superType.isInterface()) {\n      factory.setInterfaces(new Class[] { superType });\n    } else {\n      types = new Class[] { Configuration.class, TaskAttemptID.class, RecordWriter.class, OutputCommitter.class,\n          StatusReporter.class };\n      args = new Object[] { conf, taskAttemptId, null, null, null };\n      factory.setSuperclass(superType);\n    }\n\n    final Set<String> handledMethods = ImmutableSet.of(\"getConfiguration\", \"getCounter\", \n                                                  \"progress\", \"getNumReduceTasks\", \"getTaskAttemptID\");\n    factory.setFilter(new MethodFilter() {\n      @Override\n      public boolean isHandled(Method m) {\n        return handledMethods.contains(m.getName());\n      }\n    });\n    MethodHandler handler = new MethodHandler() {\n      @Override\n      public Object invoke(Object arg0, Method m, Method arg2, Object[] args) throws Throwable {\n        String name = m.getName();\n        if (\"getConfiguration\".equals(name)) {\n          return conf;\n        } else if (\"progress\".equals(name)) {\n          // no-op\n          return null;\n        } else if (\"getTaskAttemptID\".equals(name)) {\n          return taskAttemptId;\n        } else if (\"getNumReduceTasks\".equals(name)) {\n          return 1;\n        } else if (\"getCounter\".equals(name)){ // getCounter\n          if (args.length == 1) {\n            return MemPipeline.getCounters().findCounter((Enum<?>) args[0]);\n          } else {\n            return MemPipeline.getCounters().findCounter((String) args[0], (String) args[1]);\n          }\n        } else {\n          throw new IllegalStateException(\"Unhandled method \" + name);\n        }\n      }\n    };\n    try {\n      Object newInstance = factory.create(types, args, handler);\n      return (TaskInputOutputContext<?, ?, ?, ?>) newInstance;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "violation": {"line": "473", "column": "46", "severity": "warning", "message": "'{' is not preceded with whitespace.", "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck"}, "tokens": ["{", "1_NL_2_ID_SP", "Comment", "1_NL", "return", "1_SP", "Null", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "DecimalInteger", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "if", "1_SP", "(", "0_None", "String", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "Identifier", "0_None", ")", "0_None", "<WhitespaceAround>", ")", "0_None", "{", "1_SP", "</WhitespaceAround>", "Comment", "1_NL_2_ID_SP", "if", "1_SP", "(", "0_None", "Identifier", "0_None", ".", "0_None", "Identifier", "1_SP", "==", "1_SP", "DecimalInteger", "0_None", ")", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "(", "0_None", "Identifier", "0_None", "<", "0_None", "?", "0_None", ">", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "{", "1_NL_2_ID_SP", "return", "1_SP", "Identifier", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", ")", "0_None", ".", "0_None", "Identifier", "0_None", "(", "0_None", "(", "0_None", "Identifier", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ",", "1_SP", "(", "0_None", "Identifier", "0_None", ")", "1_SP", "Identifier", "0_None", "[", "0_None", "DecimalInteger", "0_None", "]", "0_None", ")", "0_None", ";", "1_NL_2_DD_SP", "}", "1_NL_2_DD_SP", "}", "1_SP", "else", "1_SP", "{", "1_NL_2_ID_SP"], "info": {"violation_beginning_token": 3226, "violation_end_token": 3228, "context_beginning_token": 3181, "context_end_token": 3292, "violation": {"line": "473", "column": "46", "severity": "warning", "message": "'{' is not preceded with whitespace.", "source": "com.puppycrawl.tools.checkstyle.checks.whitespace.WhitespaceAroundCheck", "type": "WhitespaceAround"}, "tokens_violating_in_tag": [")", "0_None", "{", "1_SP"]}}]